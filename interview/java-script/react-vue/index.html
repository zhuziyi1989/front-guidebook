<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="./favicon.ico" />
    <link rel="stylesheet" href="/umi.331878c1.css" />
    <script>
      window.routerBase = "/";
    </script>
    <script>
      //! umi version: 3.5.20
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>框架的使用 - 前端指南</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/interview/java-script/react-vue" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;./favicon.png&#x27;)" href="/">前端指南</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span><a href="/notes">笔记</a></span><span><a aria-current="page" class="active" href="/interview">关于面试</a></span><span><a href="/words">单词</a></span><span><a target="_blank" rel="noopener noreferrer" href="https://github.com/zhuziyi1989/front-guidebook">Github<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;./favicon.png&#x27;)" href="/"></a><h1>前端指南</h1><p>一份前端知识体系指南 &amp; 私人技术笔记 🎉</p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li><a href="/notes">笔记</a></li><li><a aria-current="page" class="active" href="/interview">关于面试</a></li><li><a href="/words">单词</a></li><li><a target="_blank" rel="noopener noreferrer" href="https://github.com/zhuziyi1989/front-guidebook">Github<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a target="_blank" rel="noopener noreferrer">JavaScript</a><ul><li><a href="/interview/java-script/js-basics"><span>JavaScript 语言基础</span></a></li></ul></li><li><a target="_blank" rel="noopener noreferrer">客户端</a><ul><li><a href="/interview/client"><span>客户端及其内核原理</span></a></li></ul></li><li><a target="_blank" rel="noopener noreferrer">前端构架</a><ul><li><a href="/interview/software-engineering/架构"><span>前端构架和开发效率</span></a></li></ul></li><li><a target="_blank" rel="noopener noreferrer">面试自测清单</a><ul><li><a href="/interview/slef-test"><span>面试复习导图</span></a></li></ul></li><li><a aria-current="page" class="active" href="/interview/java-script">JavaScript</a><ul><li><a href="/interview/java-script/code-question"><span>手写代码题</span></a></li><li><a href="/interview/java-script/es6-知识点"><span>ES6+ 的新特性</span></a></li><li><a href="/interview/java-script/js-interview-1"><span>JavaScript 进阶问题列表</span></a></li><li><a href="/interview/java-script/js-regular-expression"><span>正则表达式不要背</span></a></li><li><a href="/interview/java-script/performance-optimization"><span>性能专题 Performance optimization</span></a></li><li><a aria-current="page" class="active" href="/interview/java-script/react-vue"><span>框架的使用</span></a></li></ul></li><li><a href="/interview/layout">Layout</a><ul><li><a href="/interview/layout"><span>1.  HTML 5 有哪些新特性？</span></a></li></ul></li><li><a href="/interview/network">Network</a><ul><li><a href="/interview/network"><span>前端知识体系 - 网络原理</span></a></li></ul></li><li><a href="/interview/server">Server</a><ul><li><a href="/interview/server"><span>服务端应用</span></a></li></ul></li><li><a href="/interview/slef-test">面试自测清单</a><ul><li><a href="/interview/slef-test/modify-resume"><span>修改简历</span></a></li><li><a href="/interview/slef-test/html-css"><span>HTML/CSS</span></a></li><li><a href="/interview/slef-test/js-basic"><span>JavaScript</span></a></li><li><a href="/interview/slef-test/algorithm"><span>算法</span></a></li><li><a href="/interview/slef-test/frame"><span>前端框架</span></a></li><li><a href="/interview/slef-test/network"><span>网络&amp;操作系统</span></a></li><li><a href="/interview/slef-test/other"><span>其他</span></a></li></ul></li><li><a href="/interview/software-engineering">前端构架</a><ul><li><a href="/interview/software-engineering/算法"><span>算法</span></a></li></ul></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="框架的使用" data-depth="2"><a href="/interview/java-script/react-vue#框架的使用"><span>框架的使用</span></a></li><li title="1、解释单向数据流和双向数据绑定" data-depth="3"><a href="/interview/java-script/react-vue#1解释单向数据流和双向数据绑定"><span>1、解释单向数据流和双向数据绑定</span></a></li><li title="2、如何理解虚拟DOM?" data-depth="3"><a href="/interview/java-script/react-vue#2如何理解虚拟dom"><span>2、如何理解虚拟DOM?</span></a></li><li title="3、Vue双向绑定实现原理" data-depth="3"><a href="/interview/java-script/react-vue#3vue双向绑定实现原理"><span>3、Vue双向绑定实现原理</span></a></li><li title="4、Vue对比其他框架(主要关注 React)" data-depth="3"><a href="/interview/java-script/react-vue#4vue对比其他框架主要关注-react"><span>4、Vue对比其他框架(主要关注 React)</span></a></li><li title="5、客户端 MVC 与服务器端或经典 MVC 有何不同？" data-depth="3"><a href="/interview/java-script/react-vue#5客户端-mvc-与服务器端或经典-mvc-有何不同"><span>5、客户端 MVC 与服务器端或经典 MVC 有何不同？</span></a></li><li title="6、不可变数据结构（immutable data structures）解决了哪些问题？" data-depth="3"><a href="/interview/java-script/react-vue#6不可变数据结构immutable-data-structures解决了哪些问题"><span>6、不可变数据结构（immutable data structures）解决了哪些问题？</span></a></li><li title="7、hash模式和history模式的区别" data-depth="3"><a href="/interview/java-script/react-vue#7hash模式和history模式的区别"><span>7、hash模式和history模式的区别</span></a></li><li title="8、大型应用程序是否应使用静态类型？" data-depth="3"><a href="/interview/java-script/react-vue#8大型应用程序是否应使用静态类型"><span>8、大型应用程序是否应使用静态类型？</span></a></li><li title="9、Vue 和 React的一些优点和区别？" data-depth="3"><a href="/interview/java-script/react-vue#9vue-和-react的一些优点和区别"><span>9、Vue 和 React的一些优点和区别？</span></a></li><li title="10、React 生命周期图谱" data-depth="3"><a href="/interview/java-script/react-vue#10react-生命周期图谱"><span>10、React 生命周期图谱</span></a></li><li title="11、React 组合 vs 继承" data-depth="3"><a href="/interview/java-script/react-vue#11react-组合-vs-继承"><span>11、React 组合 vs 继承</span></a></li><li title="12、React 组件模式有哪几种？" data-depth="3"><a href="/interview/java-script/react-vue#12react-组件模式有哪几种"><span>12、React 组件模式有哪几种？</span></a></li><li title="13、高阶组件概念" data-depth="3"><a href="/interview/java-script/react-vue#13高阶组件概念"><span>13、高阶组件概念</span></a></li><li title="HOC 与容器组件模式的区别？" data-depth="3"><a href="/interview/java-script/react-vue#hoc-与容器组件模式的区别"><span>HOC 与容器组件模式的区别？</span></a></li><li title="什么事柯里化？" data-depth="3"><a href="/interview/java-script/react-vue#什么事柯里化"><span>什么事柯里化？</span></a></li><li title="优化一个react组件的性能" data-depth="3"><a href="/interview/java-script/react-vue#优化一个react组件的性能"><span>优化一个react组件的性能</span></a></li><li title="React 组件之间通信方式？" data-depth="3"><a href="/interview/java-script/react-vue#react-组件之间通信方式"><span>React 组件之间通信方式？</span></a></li><li title="Fragments" data-depth="3"><a href="/interview/java-script/react-vue#fragments"><span>Fragments</span></a></li><li title="单页面应用路由实现原理" data-depth="3"><a href="/interview/java-script/react-vue#单页面应用路由实现原理"><span>单页面应用路由实现原理</span></a></li><li title="React Hooks" data-depth="3"><a href="/interview/java-script/react-vue#react-hooks"><span>React Hooks</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h2 id="框架的使用"><a aria-hidden="true" tabindex="-1" href="/interview/java-script/react-vue#框架的使用"><span class="icon icon-link"></span></a>框架的使用</h2><h3 id="1解释单向数据流和双向数据绑定"><a aria-hidden="true" tabindex="-1" href="/interview/java-script/react-vue#1解释单向数据流和双向数据绑定"><span class="icon icon-link"></span></a>1、解释单向数据流和双向数据绑定</h3><p>只有 UI 控件 才存在双向，非 UI控件 只有单向。全局性数据流使用单向，易跟踪调试。局部性数据流使用双向，简单易用。</p><ul><li><a target="_blank" rel="noopener noreferrer" href="https://www.zhihu.com/question/49964363">单向数据绑定和双向数据绑定的优缺点，适合什么场景？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li><a target="_blank" rel="noopener noreferrer" href="http://stylechen.com/react-flux.html">React 应用的架构模式 Flux<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul><h3 id="2如何理解虚拟dom"><a aria-hidden="true" tabindex="-1" href="/interview/java-script/react-vue#2如何理解虚拟dom"><span class="icon icon-link"></span></a>2、如何理解虚拟DOM?</h3><details><summary>查看解析</summary><p>参考资料：<a target="_blank" rel="noopener noreferrer" href="https://www.zhihu.com/question/29504639">如何理解虚拟DOM? @zhihu<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><ul><li>步骤一：用JS对象模拟DOM树</li><li>步骤二：比较两棵虚拟DOM树的差异 → 深度优先遍历，标记并记录差异 → 差异类型 → 列表对比算法</li><li>步骤三：把差异应用到真正的DOM树上</li></ul><p>关键技术：batching(批处理)、Diff算法的优化:</p><div class="__dumi-default-code-block"><pre class="prism-code language-text"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">batching(批处理)：将所有DOM的操作搜集打包在js对象中完成，然后一次性的递交给真实DOM（性能上只刷新一次）</span></div><div class="token-line"><span class="token plain">Diff算法的优化：将标准的diff算法的O(n^3)复杂度降低到了O(n)，主要得益于对新旧DOM树进行了一个深度的优先遍历，并对每个节点做唯一 id 标记</span></div></pre></div><p>逐层进行节点比较<img src="/static/dom-diff.cae0ec46.jpg" alt="dom-diff"/></p><p>更多解析：<a target="_blank" rel="noopener noreferrer" href="https://infoq.cn/article/react-dom-diff">深入浅出 React（四）：虚拟 DOM Diff 算法解析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><blockquote><p>Tips：由于特有的 DOM Diff 算法，我们在实现自己的组件时，保持稳定的 DOM 结构会有助于性能的提升。例如，我们有时可以通过 CSS 隐藏或显示某些节点，而不是真的移除或添加 DOM 节点。</p></blockquote><p>优势：结合Node Server层来说，实现服务端与浏览器端的同构更为方便。</p><p>类比：CPU 内存(纯JS操作)和硬盘(纯DOM操作)的关系。</p></details><h3 id="3vue双向绑定实现原理"><a aria-hidden="true" tabindex="-1" href="/interview/java-script/react-vue#3vue双向绑定实现原理"><span class="icon icon-link"></span></a>3、Vue双向绑定实现原理</h3><p>➤ 参考资料：<a target="_blank" rel="noopener noreferrer" href="https://segmentfault.com/a/1190000006599500">《剖析Vue原理&amp;实现双向绑定MVVM》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><ul><li><p>单向数据流架构在哪些方面适合MVC ？</p><p>MVC 拥有大约 50 年的悠久历史，并已演变为 MVP，MVVM 和 MV *。两者之间的相互关系是什么？如果 MVC 是架构模式，那么单向数据流是什么？这些竞争模式是否能解决同样的问题？</p></li></ul><h3 id="4vue对比其他框架主要关注-react"><a aria-hidden="true" tabindex="-1" href="/interview/java-script/react-vue#4vue对比其他框架主要关注-react"><span class="icon icon-link"></span></a>4、Vue对比其他框架(主要关注 React)</h3><ol><li>React需要开发者更多的关注子组件的重渲染，如何的避免这个问题引起的性能问题，然而在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染。你可以理解为每一个组件都已经自动获得了 <code>shouldComponentUpdate</code>，并且没有上述的子树问题限制。因此 Vue 的这个特点使得开发者不再需要考虑此类优化，<u>从而能够更好地专注于应用本身。</u></li><li>Vue 的路由库和状态管理库都是由官方维护支持且与核心库同步更新的。React 则是选择把这些问题交给社区维护，因此创建了一个更分散的生态系统。但相对的，React 的生态系统相比 Vue 更加繁荣。</li><li>React 比 Vue 更好的地方，比如更丰富的生态系统，React 国际大厂的维护，Vue 初期则是个人开发者。</li></ol><blockquote><p>更多对比查看 Vue 官方解释<a target="_blank" rel="noopener noreferrer" href="https://cn.vuejs.org/v2/guide/comparison#React">https://cn.vuejs.org/v2/guide/comparison#React<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote><h3 id="5客户端-mvc-与服务器端或经典-mvc-有何不同"><a aria-hidden="true" tabindex="-1" href="/interview/java-script/react-vue#5客户端-mvc-与服务器端或经典-mvc-有何不同"><span class="icon icon-link"></span></a>5、客户端 MVC 与服务器端或经典 MVC 有何不同？</h3><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">提示：经典 MVC 是适用于桌面应用程序的 Smalltalk MVC。在 Web 应用中，至少有两个不同的数据 MVC 周期。</span></div></pre></div><h3 id="6不可变数据结构immutable-data-structures解决了哪些问题"><a aria-hidden="true" tabindex="-1" href="/interview/java-script/react-vue#6不可变数据结构immutable-data-structures解决了哪些问题"><span class="icon icon-link"></span></a>6、不可变数据结构（immutable data structures）解决了哪些问题？</h3><p>可变数据的好处是 <strong>节省内存</strong>或 <strong>利用可变性做一些事情</strong>，但在复杂的开发中它的副作用也挺多，于是出现了浅拷贝和深拷贝，JavaScript 原生方法里都是浅拷贝(例如Object.assign、Object.freeze、ES6中的解构)，在实际开发中浅拷贝通常不够用，于是 Facebook 推出来了不可变数据结构 Immutable.js</p><p>在 React 开发中，频繁操作 <code>State 对象</code>或是 <code>Store</code>，Render 方法根据数据改变来执行，可变数据可能导致性能上的浪费，如果配合 immutable.js 快速、安全、方便，可以避免这种问题。</p><p>immutable.js在数据比较上也有优化，只需要对外层数据判断即可(如果数据结构比较深，可避免数据比较带来的性能问题)，但 API 上设计过于细致，导致库脚本本身比较重，因此不太适用于移动端。</p><p>➤ 参考资料：<a target="_blank" rel="noopener noreferrer" href="https://www.zhihu.com/question/28016223">facebook immutable.js 意义何在，使用场景？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><h3 id="7hash模式和history模式的区别"><a aria-hidden="true" tabindex="-1" href="/interview/java-script/react-vue#7hash模式和history模式的区别"><span class="icon icon-link"></span></a>7、hash模式和history模式的区别</h3><p>hash模式是依靠onhashchange事件(监听location.hash的改变)，而history模式是主要是依靠的HTML5 history中新增的两个方法，pushState()可以改变url地址且不会发送请求，replaceState()可以读取历史记录栈,还可以对浏览器记录进行修改。</p><h3 id="8大型应用程序是否应使用静态类型"><a aria-hidden="true" tabindex="-1" href="/interview/java-script/react-vue#8大型应用程序是否应使用静态类型"><span class="icon icon-link"></span></a>8、大型应用程序是否应使用静态类型？</h3><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">如何比较 TypeScript/Flow 与 Elm/ReasonML/PureScript 等 JS 转换语言？这些方法的优缺点是什么？</span></div></pre></div><h3 id="9vue-和-react的一些优点和区别"><a aria-hidden="true" tabindex="-1" href="/interview/java-script/react-vue#9vue-和-react的一些优点和区别"><span class="icon icon-link"></span></a>9、Vue 和 React的一些优点和区别？</h3><p>几个切入点：</p><ul><li>数据驱动</li><li>数据单向流</li><li>虚拟DOM（可减少直接操作DOM，性能上的优化）</li><li>Vue 的双向绑定（vue2.x实现原理：<strong>Object.defineProperty()来实现数据劫持</strong>、发布者-订阅者模式。<a target="_blank" rel="noopener noreferrer" href="https://juejin.im/entry/5923973da22b9d005893805a">参考资料<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 但Vue3.x版本之后就改用Proxy进行实现。<a target="_blank" rel="noopener noreferrer" href="https://www.cnblogs.com/tugenhua0707/p/10261170.html">参考资料<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）</li><li>无缝结合 webpack 等打包工具，使得开发模式更现代，具有模块化、组件化式的。</li></ul><p>区别：</p><ul><li><p>模板渲染的方式区别：</p><p>​ React在JSX中使用<strong>原生的JS语法</strong>来实现<u>插值，条件渲染，循环渲染</u>等等。而Vue则需要依赖<u>指令</u>来进行，更加容易上手但是封装的程度更高，调试成本更大，难以定位Bug。</p></li><li><p>性能差异：</p><p>​ 在React中组件的更新渲染是从数据发生变化的<u>根组件开始往子组件</u>逐层重新渲染，而组件的生命周期有shouldComponentUpdate()函数供给开发者优化组件在不需要更新的时候返回false。而在Vue中是通过watcher监听到数据的变化之后通过自己的diff算法，在virtualDom中直接找到以最低成本更新视图的方式。</p></li><li><p>Vue更适合开发周期更短的相对小型的项目，React更适合构建稳定大型的应用，可定制化的能力更强。</p></li></ul><h3 id="10react-生命周期图谱"><a aria-hidden="true" tabindex="-1" href="/interview/java-script/react-vue#10react-生命周期图谱"><span class="icon icon-link"></span></a>10、React 生命周期图谱</h3><p>➤ 参考资料：<a target="_blank" rel="noopener noreferrer" href="https://t.cn/RmV1t56">https://t.cn/RmV1t56<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>  废弃了三个带有 Will 的钩子函数，是为react新版本的异步渲染做铺垫。</p><p><img src="/static/lifeCycle.c1852172.jpg" alt="lifeCycle"/></p><h3 id="11react-组合-vs-继承"><a aria-hidden="true" tabindex="-1" href="/interview/java-script/react-vue#11react-组合-vs-继承"><span class="icon icon-link"></span></a>11、React 组合 vs 继承</h3><h4 id="组合方式"><a aria-hidden="true" tabindex="-1" href="/interview/java-script/react-vue#组合方式"><span class="icon icon-link"></span></a>组合方式</h4><p>组件可以接受任意 props，包括基本数据类型，React 元素以及函数。</p><ol><li>包含关系</li><li>特例关系</li></ol><h3 id="12react-组件模式有哪几种"><a aria-hidden="true" tabindex="-1" href="/interview/java-script/react-vue#12react-组件模式有哪几种"><span class="icon icon-link"></span></a>12、React 组件模式有哪几种？</h3><ol><li><p>有状态(stateful)组件 和 无状态(stateless)组件</p></li><li><p>容器(Container) 组件 和 展示(Presentational) 组件</p></li><li><p>高阶组件(Higher order components , HOC ）</p></li></ol><h3 id="13高阶组件概念"><a aria-hidden="true" tabindex="-1" href="/interview/java-script/react-vue#13高阶组件概念"><span class="icon icon-link"></span></a>13、高阶组件概念</h3><p>高阶组件是**<em>参数为组件</em><strong>，</strong><em>返回值</em>**为新组件的函数。(组件以参数形式进入，返回一个新组件，说白了就是抽象，并没多高阶...)</p><h4 id="一些建议"><a aria-hidden="true" tabindex="-1" href="/interview/java-script/react-vue#一些建议"><span class="icon icon-link"></span></a>一些建议</h4><ol><li>HOC 是纯函数，没有副作用。</li><li>HOC 不应该修改传入组件，而应该使用组合的方式，通过将组件包装在容器组件中实现功能。</li></ol><h3 id="hoc-与容器组件模式的区别"><a aria-hidden="true" tabindex="-1" href="/interview/java-script/react-vue#hoc-与容器组件模式的区别"><span class="icon icon-link"></span></a>HOC 与容器组件模式的区别？</h3><h3 id="什么事柯里化"><a aria-hidden="true" tabindex="-1" href="/interview/java-script/react-vue#什么事柯里化"><span class="icon icon-link"></span></a>什么事柯里化？</h3><p>柯里化：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p><p>Currying 使用场景：参数复用、延迟执行。</p><ol><li><p>渲染回调（Render Callbacks）：<code>this.props.children</code>方式，也就是函数作为子组件。</p></li><li><p>新的 API：Hooks</p></li></ol><blockquote><p>参考：<a target="_blank" rel="noopener noreferrer" href="https://github.com/yueshuiniao/blog/issues/1">[译]React 组件模式<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote><h3 id="优化一个react组件的性能"><a aria-hidden="true" tabindex="-1" href="/interview/java-script/react-vue#优化一个react组件的性能"><span class="icon icon-link"></span></a>优化一个react组件的性能</h3><ol><li>减少渲染的节点的量</li><li>减少不必要的嵌套</li><li>减少setState的操作次数</li><li>在需要大量滚动列表的组件，可使用虚拟列表<a target="_blank" rel="noopener noreferrer" href="https://github.com/bvaughn/react-virtualized">react-virtualized<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li>避免直接使用<strong>箭头函数</strong>作为<strong>事件处理器</strong>，因为每一次渲染都会<u>重新创建一个新的事件处理器</u>。</li></ol><h3 id="react-组件之间通信方式"><a aria-hidden="true" tabindex="-1" href="/interview/java-script/react-vue#react-组件之间通信方式"><span class="icon icon-link"></span></a>React 组件之间通信方式？</h3><h4 id="常见应用场景"><a aria-hidden="true" tabindex="-1" href="/interview/java-script/react-vue#常见应用场景"><span class="icon icon-link"></span></a>常见应用场景</h4><ol><li><p>父组件 → 子组件：利用<code>props</code>实现数据传递</p></li><li><p>子组件 → 父组件：</p><ul><li>回调函数实现，依靠父组件传下来的 <code>callback</code> 函数执行，改变 父组件 组件的状态，或者把 子组件 的 state 通知 父组件 。</li><li>自定义事件机制</li></ul></li><li><p>跨层级（祖孙）组件：</p><ul><li><p>层层组件传递<code>props</code></p></li><li><p>使用<code>context</code>技术</p></li></ul></li><li><p>兄弟组件：通常是依赖共有的顶级容器（即共有父组件）处理</p></li><li><p>无嵌套关系组件：自定义事件机制，常用的有发布/订阅模式，通常是依赖共有的顶级容器处理或者第三方的状态管理器（如Redux/Mbox）。其实原理都是相通的，兄弟 A （发布者）的 value 发生变化，分发的时候把 value 值告诉一个中间者 C（订阅者） ，C 会自动告知 B，实现 B 的自动render 。</p></li></ol><h4 id="大型应用解决方案"><a aria-hidden="true" tabindex="-1" href="/interview/java-script/react-vue#大型应用解决方案"><span class="icon icon-link"></span></a>大型应用解决方案</h4><p>如果你的项目非常大，那可能需要一个状态管理工具，通过状态管理工具把组件之间的关系，和关系的处理逻辑从组建中抽象出来，并集中化到统一的地方来处理，Redux就是一个非常不错的状态管理工具，当然还有这些Mobx、Rematch、reselect 不错的工具。</p><h4 id="redux-相关理解"><a aria-hidden="true" tabindex="-1" href="/interview/java-script/react-vue#redux-相关理解"><span class="icon icon-link"></span></a>Redux 相关理解</h4><ol><li><p>Web应用是一个状态机，视图与状态是一一对应的。其次，所有的状态，保存在一个对象里面（即单一数据源）。</p></li><li><p>Redux 就是一个 JavaScript 状态容器(Store)，这个状态(State)只读，想要改变必须使用纯函数(Reducers)来执行修改。</p></li></ol><p><img src="/static/redux-1.d1a8091a.png" alt="redux-1.png"/></p><p>Redux的工作流程:</p><p><img src="/static/redux-2.53172d23.png" alt="redux-2.png"/></p><blockquote><p>参考：</p><ul><li><a target="_blank" rel="noopener noreferrer" href="https://github.com/sunyongjian/blog/issues/27">React组件之间的通信<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li><a target="_blank" rel="noopener noreferrer" href="http://www.alloyteam.com/2016/01/some-methods-of-reactjs-communication-between-components/">ReactJS 组件间沟通的一些方法（From Alloyteam）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li><a target="_blank" rel="noopener noreferrer" href="https://tech.meituan.com/2017/07/14/redux-design-code.html">Redux从设计到源码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></blockquote><h3 id="fragments"><a aria-hidden="true" tabindex="-1" href="/interview/java-script/react-vue#fragments"><span class="icon icon-link"></span></a>Fragments</h3><p>多个组件并排渲染，需要使用一个 HTML 比偶钱包过，一般增加一个 <code>&lt;div&gt;</code>  即可，但引起了 DOM 结构的冗([rǒng])余，于是出现了 <code>Fragment</code>，直接用 <code>&lt;React.Fragment&gt;</code> 代替 <code>&lt;div&gt;</code></p><h3 id="单页面应用路由实现原理"><a aria-hidden="true" tabindex="-1" href="/interview/java-script/react-vue#单页面应用路由实现原理"><span class="icon icon-link"></span></a>单页面应用路由实现原理</h3><p><a target="_blank" rel="noopener noreferrer" href="https://github.com/youngwind/blog/issues/109#">以 React-Router 为例<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p><h3 id="react-hooks"><a aria-hidden="true" tabindex="-1" href="/interview/java-script/react-vue#react-hooks"><span class="icon icon-link"></span></a>React Hooks</h3><p>参考资料：</p><ol><li><a target="_blank" rel="noopener noreferrer" href="https://juejin.im/post/5bf20ce6e51d454a324dd0e6">精读《怎么用 React Hooks 造轮子》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li><a target="_blank" rel="noopener noreferrer" href="https://zh-hans.reactjs.org/docs/hooks-intro.html">Hook 官方解读<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ol></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/zhuziyi1989/front-guidebook/edit/master/docs/interview/JavaScript/react-vue.md">Edit this doc on GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="Last update: ">2021/12/21 16:48:09</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script src="/umi.302945c4.js"></script>
  </body>
</html>
